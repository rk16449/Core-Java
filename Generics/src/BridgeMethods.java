// Consider classes (after compilation):

class bNode {
	private Object first;

	public bNode(Object first) {
		this.first = first;
	}

	public void setFirst(Object first) {
		this.first = first;
	}
}

class mNode extends bNode {
	public mNode(Integer first) {
		super(first);
	}
	public void setFirst(Integer first) {
		super.setFirst(first);
	}
	
	// after type erasure method signatures do not match
	
	// This Bridge method would be generated by compiler
	// 
	public void setFirst(Object first) {
		setFirst((Integer) first);
	}
	
	// The bridge method has the same method signature as the bNode setFirst method after type erasure
	// delegates to the original setFirst method
}

public class BridgeMethods {

}
